#!/bin/bash
# ============================================================================
# VALIDATION SECRETS - PRE-COMMIT HOOK
# ============================================================================
# Détecte les secrets (clés API, tokens) dans les fichiers staged pour commit
# et bloque le commit si des patterns suspects sont trouvés.
#
# Usage:
#   bash scripts/validate-secrets.sh
#   bash scripts/validate-secrets.sh --install-hook
#
# Patterns détectés:
#   - OpenAI: sk-proj-*
#   - Groq: gsk_*
#   - Anthropic: sk-ant-api*
#   - Google: AIzaSy*
#   - Brevo: xkeysib-*
#   - DeepSeek: sk-* (générique)
#   - Resend: re_*
#   - Tokens longs: 32+ caractères hexadécimaux
#
# Installation pre-commit hook:
#   bash scripts/validate-secrets.sh --install-hook
# ============================================================================

set -euo pipefail

# Couleurs pour logs
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# ----------------------------------------------------------------------------
# Fonctions Helper
# ----------------------------------------------------------------------------

log_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

log_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

log_error() {
    echo -e "${RED}❌ $1${NC}"
}

# ----------------------------------------------------------------------------
# Patterns Secrets à Détecter
# ----------------------------------------------------------------------------

# Tableau des patterns (pattern:description)
declare -a SECRET_PATTERNS=(
    "sk-proj-:OpenAI API Key"
    "gsk_:Groq API Key"
    "sk-ant-api:Anthropic API Key"
    "AIzaSy:Google API Key"
    "xkeysib-:Brevo API Key"
    "re_[A-Za-z0-9]{20,}:Resend API Key"
    "[0-9a-f]{64}:Encryption Key (64 hex)"
    "[0-9a-f]{32}:Secret Token (32 hex)"
)

# Fichiers toujours exclus de la validation
declare -a EXCLUDED_FILES=(
    ".env.template"
    ".env.secrets.template"
    ".env.production.template"
    ".env.production.example"
    "scripts/validate-secrets.sh"
    "docs/"
    "memory/"
)

# ----------------------------------------------------------------------------
# Installation Pre-Commit Hook
# ----------------------------------------------------------------------------

install_hook() {
    local hook_file=".git/hooks/pre-commit"
    local hook_content='#!/bin/bash
# Auto-generated by scripts/validate-secrets.sh
bash scripts/validate-secrets.sh
exit $?
'

    log_info "Installation du pre-commit hook..."

    # Créer dossier hooks si inexistant
    mkdir -p .git/hooks

    # Vérifier si hook existe déjà
    if [ -f "$hook_file" ]; then
        log_warning "Pre-commit hook existe déjà: $hook_file"

        # Vérifier si notre validation est déjà présente
        if grep -q "validate-secrets.sh" "$hook_file"; then
            log_success "Validation secrets déjà configurée dans pre-commit hook"
            return 0
        fi

        # Backup du hook existant
        local backup_file="${hook_file}.backup.$(date +%s)"
        cp "$hook_file" "$backup_file"
        log_info "Backup créé: $backup_file"

        # Append notre validation
        echo "" >> "$hook_file"
        echo "# Validation secrets (ajouté automatiquement)" >> "$hook_file"
        echo "bash scripts/validate-secrets.sh" >> "$hook_file"
        echo "exit \$?" >> "$hook_file"

        log_success "Validation secrets ajoutée au pre-commit hook existant"
    else
        # Créer nouveau hook
        echo "$hook_content" > "$hook_file"
        chmod +x "$hook_file"
        log_success "Pre-commit hook créé: $hook_file"
    fi

    log_success "Installation terminée avec succès"
    log_info "Désormais, chaque commit sera validé pour détecter les secrets"
}

# ----------------------------------------------------------------------------
# Validation Fichiers Staged
# ----------------------------------------------------------------------------

validate_staged_files() {
    local exit_code=0
    local secrets_found=0

    log_info "Validation des fichiers staged pour commit..."

    # Obtenir la liste des fichiers staged
    local staged_files
    if ! staged_files=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null); then
        log_warning "Pas de repository git détecté"
        return 0
    fi

    # Vérifier si des fichiers sont staged
    if [ -z "$staged_files" ]; then
        log_info "Aucun fichier staged pour commit"
        return 0
    fi

    log_info "$(echo "$staged_files" | wc -l | tr -d ' ') fichiers staged à valider"

    # Valider chaque fichier staged
    while IFS= read -r file; do
        # Ignorer fichiers inexistants (deleted)
        [ ! -f "$file" ] && continue

        # Vérifier si fichier doit être exclu
        local excluded=false
        for excluded_pattern in "${EXCLUDED_FILES[@]}"; do
            if [[ "$file" == *"$excluded_pattern"* ]]; then
                excluded=true
                break
            fi
        done

        [ "$excluded" = true ] && continue

        # Valider le fichier
        log_info "Validation: $file"

        # Vérifier chaque pattern
        for pattern_desc in "${SECRET_PATTERNS[@]}"; do
            local pattern="${pattern_desc%%:*}"
            local description="${pattern_desc#*:}"

            # Rechercher le pattern dans le fichier staged
            if git show ":$file" 2>/dev/null | grep -qE "$pattern"; then
                log_error "SECRET DÉTECTÉ dans $file"
                log_error "  Type: $description"
                log_error "  Pattern: $pattern"

                # Afficher les lignes concernées (masquées)
                local matching_lines
                matching_lines=$(git show ":$file" 2>/dev/null | grep -nE "$pattern" | head -5)

                while IFS= read -r line; do
                    local line_num="${line%%:*}"
                    local line_content="${line#*:}"
                    # Masquer le secret (afficher seulement 10 premiers caractères)
                    local masked_content="${line_content:0:30}***[MASKED]***"
                    log_error "    Ligne $line_num: $masked_content"
                done <<< "$matching_lines"

                secrets_found=$((secrets_found + 1))
                exit_code=1
            fi
        done
    done <<< "$staged_files"

    # Rapport final
    echo ""
    if [ $secrets_found -eq 0 ]; then
        log_success "Validation réussie : Aucun secret détecté"
    else
        log_error "VALIDATION ÉCHOUÉE : $secrets_found secret(s) détecté(s)"
        echo ""
        log_warning "Actions recommandées:"
        log_info "  1. Déplacer les secrets vers .env.secrets (gitignored)"
        log_info "  2. Utiliser les templates (.env.template, .env.secrets.template)"
        log_info "  3. Unstage les fichiers concernés: git reset HEAD <fichier>"
        log_info "  4. Ne JAMAIS committer de vraies clés API"
        echo ""
        log_error "Commit BLOQUÉ pour protéger les secrets"
    fi

    return $exit_code
}

# ----------------------------------------------------------------------------
# Validation All Files (scan complet)
# ----------------------------------------------------------------------------

validate_all_files() {
    log_info "Scan complet du repository (tous les fichiers)..."
    log_warning "Cette opération peut prendre du temps sur de gros repositories"

    local secrets_found=0

    # Rechercher dans tous les fichiers trackés par git
    local all_files
    all_files=$(git ls-files)

    while IFS= read -r file; do
        # Ignorer fichiers exclus
        local excluded=false
        for excluded_pattern in "${EXCLUDED_FILES[@]}"; do
            if [[ "$file" == *"$excluded_pattern"* ]]; then
                excluded=true
                break
            fi
        done

        [ "$excluded" = true ] && continue
        [ ! -f "$file" ] && continue

        # Vérifier chaque pattern
        for pattern_desc in "${SECRET_PATTERNS[@]}"; do
            local pattern="${pattern_desc%%:*}"
            local description="${pattern_desc#*:}"

            if grep -qE "$pattern" "$file" 2>/dev/null; then
                log_warning "SECRET POTENTIEL dans $file ($description)"
                secrets_found=$((secrets_found + 1))
            fi
        done
    done <<< "$all_files"

    if [ $secrets_found -eq 0 ]; then
        log_success "Aucun secret détecté dans le repository"
    else
        log_warning "$secrets_found secret(s) potentiel(s) détecté(s)"
        log_info "Vérifiez manuellement les fichiers listés ci-dessus"
    fi
}

# ----------------------------------------------------------------------------
# Main
# ----------------------------------------------------------------------------

main() {
    local mode="${1:-}"

    case "$mode" in
        --install-hook)
            install_hook
            ;;
        --scan-all)
            validate_all_files
            ;;
        --help)
            echo "Usage: $0 [--install-hook|--scan-all|--help]"
            echo ""
            echo "Options:"
            echo "  (aucune)         Valider fichiers staged (mode pre-commit)"
            echo "  --install-hook   Installer le pre-commit hook"
            echo "  --scan-all       Scanner tous les fichiers du repository"
            echo "  --help           Afficher cette aide"
            ;;
        *)
            validate_staged_files
            ;;
    esac
}

# Exécuter
main "$@"
